---
layout: post
title:  "Interfaces"
subtitle: "Dependency Inversion in Systems Design"
author: "Nick Landolfi"
date: 2015-02-01 12:00:00
categories: lando
---

Lately I have been building the core stack of [elos](https://github.com/elos/server). The structure of the is, relative to my experience, complex. It includes an [HTTP server](https://github.com/elos/server/blob/master/config/server.go) which manages an [API](https://github.com/elos/server/blob/master/config/routes.go) and this server [can upgrade](https://github.com/elos/server/blob/master/conn/web_socket.go) requests to websockets, which are then managed [autonomously](https://github.com/elos/autonomous) as [client data agents](https://github.com/elos/server/blob/master/agents/client_data.go) and require another [multiplexed transfer](https://github.com/elos/server/tree/master/transfer) [protocol](https://github.com/elos/documentation/blob/master/data/transfer/protocol.md). There is an [ontology of models](https://github.com/elos/server/tree/master/models), which fill elos' data needs. There are [services](https://github.com/elos/server/blob/master/config/services.go) which run autonomously of the system and inspect a user's data periodically. The elos "server" is really a backbone of a fair amount of infrastructure. It becomes increasingly difficult to think about the entire system when working on one particular aspect of it.

Additionally I should say that the stack is built using [Go](https://golang.org). Go is _not_ object-oriented. That is not to say Go does not encourage data modeling and encapsulation - it absolutely does, but the sometimes cumbersome layer of OO design is stripped, and though this can clarify composibility and simplify dependency concerns, it can - at times - complicate thinking about these different pieces of infrastructure. A server, I imagine, as some object-like entity. HTTP routing - well I can see more as a series of functions - but then route handlers, again, objects? In Go, you solve this conceptual paradox using interfaces. You don't depend of things for _who_ they are, you depend on things for _what_ they do.

In Go, you define an interface as a type that implements a collection of functions - that type may not even know the interface exists - but if it happens to implement the requisite API it satisfies the interface type. This causes the system architect to think about different pieces of structure in terms of their capabilities - which interface they satisfy - rather that being concerned what data structure it is exactly. This paradigm shift is important, the engineer need not worry about with the underlying data structure and its implementation and can start thinking about structure as the orchestra of several different pieces of functionality.

Let's look at an example, say I am writing a http server. It handles certain endpoints. As it happens, we want our server to do meaningful things, so we need some sort of persistence. We want to model a user and that user's tasks. How should we go about it? Well, at first pass, we decide what kind of persistence we want. Maybe we jump the SQL ship and head for mongo. Maybe we go simple and use SQLite3. We design our data structures in Go to match the database we select - as we inevitably must. Then we give a MongoDB to each route handler, so that when when we hit the url `/users/add_task` with some task JSON, we can create the task, link it to the user and persist both objects.

So we have the desired functionality: a server that can add a task to a user, but it depends on several things: a MongoUser, a MongoTask and a MongoDB. On cursory glance you might imagine that this is like 3 dependencies. But what if I rely on the MongoUser's name property AND tasks property. I really depend on these data structures apropos to the number of times I expect something to be there. So I expect the MongoDB has a save function of some sort. But a MongoDB can only save a MongoModel. Our system is crippled by it's dependence on mongo, and the design is suffering.

Here, there are several instances where we can examine the working power of interfaces, and where interface can help us decouple our code. It is useful first, to note that I was only able to inject the user, task and db into the http handler because Go's std http library registers and endpoint to a Handler interface. A handler must only implement the ServeHTTP(w http.ResponseWriter, r *http.Request) function. So I can write a MongoHandler data structure that has a DB property and "knows about" my MongoUser and MongoTask models. I needn't subclass anything. I needn't use exactly some specific structure defined in the http package. I should mention that other languages have interfaces too - and use them to great effect. I think one Go elevates the power of interfaces by making them the only effective way to model some sort of archetype/subclass paradigm (remember not OO).

Say I have the MongoUser and MongoTask structures, I don't really want to know about these structures - all I really need is the ability to set a user's name and give it tasks. I needn't know that the MongoUser stores the name property as a string struct field named "EName". That the "TaskIDs" property is a mongo.ObjectId set. But if I pass the data structure directly to the handler I must know these things. We run into the same troubles with our database structure. If I am using Mongo - the persist functionality I want may always be something like "UpsertId" - but this may be different for an SQL variant. By giving my handler a MongoDB, I force it to be coupled to my Mongo-based persistence and my Mongo-compatibly implemented data ontology.

So what to do? We should define a DB interface. All this interface need be is something that allows me to find and store records. Likewise I can define User and Task interfaces, that allow me to manipulate these models. I can now think about my ontology in more general terms, and I suddenly don't care about the implementation of my database or my models. And I shouldn't. The http handling aspect of my application shouldn't care. My underlying MongoUser can implement both a general data.Record interface and the models.User interface. My DB interface knows how to save Records, so it knows how to save the MongoUser, and my route knows how to AddTask to a user, so it can add the new task. I could drop in a SQL variant tomorrow and so long as it fulfilled our interfaces it would work[^1].

Thinking about things in terms of the interfaces they expose simplifies system design. While building large computer systems the problem of dependencies and services and which packages supply what implementation and which services provide what functionality becomes an atrocious medley of coupled, inextricably linked software. Dependency inversion - stating the interfaces which you need, allows you to decouple software. Additionally it simplifies the actual implementations. Take our Mongo vs SQL example, so long as the database can be queried and can persist records it works with elos' stack. It doesn't matter how actually "persists" the information. For all I know - my database sends text messages to a monkey who stores the data a bunch of banana binary. **It does not matter**. There are fifty different ways to implement a data store. There are serveral good ways today. And when there is a better way tomorrow, elos will drop it in - and the system will still work.

[^1] What I've described here is very much like what elos uses. See the [data](https://github.com/elos/data) package where we define these abstract data modeling interfaces. See the [models](https://github.com/elos/server/tree/master/models) package for the elos-specific data interfaces.
