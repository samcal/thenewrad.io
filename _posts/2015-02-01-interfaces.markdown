---
layout: post
title:  "Interfaces"
subtitle: "Dependency Inversion in Systems Design"
author: "Nick Landolfi"
date: 2014-02-01 12:00:00
categories: lando
---

Lately I have been building the core stack for [elos](https://github.com/elos/server). The structure of the system is, relative to my experience, rather complex. That stack includes an HTTP server which manages a RESTful API and this server can upgrade requests to websockets, which are then managed autonmously as client data agents and require another multiplexed transfer protocol. There is an ontology of models, which fill elos' data needs. There are services which run autonomously of the system and inspect a user's data periodically. Rhe elos "server" is really a backbone of a good amount of infrastructure. It becomes increasingly difficult to think about the entire system when working on a particular aspect of it.

Additionally I should say that the stack is built using [Go](https://golang.org). Go is _not_ object-oriented. That is not to say Go does not encourage data modeling and encapsulation - it absolutely does, but the sometimes cumbersome layer of OO design is stripped, and though this can clarify composibility and simplify dependency concerns, it can - at times - complicate thinking about these different pieces of infrastructure. A server, I imagine, as some object-like entity. HTTP routing - well I can see more as a series of functions - but then route handlers, again, objects? In Go, you use interfaces. You don't depend of things for _who_ they are, you depend on things for _what_ they do.

In Go, you define an interface as a type that implements a collection of functions - that type may not know the interface exists - but if it happens to implement the requisite API it satisfies the interface typee. This causes the system architect to think about different pieces of structure as what they can do - which interface they satisfy - rather that being concerned what data structure it is exactly. The engineer need not worry about with the underlying data structure and its implementation.

Let's look at an example. I am writing a http server. It handles certain endpoints. As it happens, we want our server to do meaningful things, so we need some sort of persistence. We want to model a user and that user's tasks. How should we go about it? Well, at first pass, we decide what kind of persistence we want. Maybe we jump the SQL ship and head for mongo. Maybe we go simple and use SQLite3. We design our data structures in Go to match the database we select - as we inevitably must. Then we give a MongoDB to each route handler, so that when when we hit the url `/users/add_task` with some task JSON, we can create the task, link it to the user and persist both objects.

Now we have a server that depends on a MongoUser, a MongoTask and a MongoDB. Now a MongoDB can only save a MongoModel. There are several places here where I can demonstrate the power of interfaces. Firstly, I can only inject the user, task and db to the http handler because Go's std library http server registers difference endpoints to different handlers. All a handler must implement is the ServeHTTP(w http.ResponseWriter, r *http.Request) function. So I can write a MongoHandler data structure that has a DB property and knowsabout my MongoUser and MongoTask models. I needn't subclass anything. I needn't use exactly some specific structure defined in the http std library package. Other languages have interfaces too - they are not specific to to Go. But the power of Go's interfaces follow. Say I have the MongoUser and MongoTask structures, I don't really want to know about them - a I really only need to be able to set a user's name and give it tasks. I needn't know that the MongoUser stores the name property as a string struct field named "EName". But if I pass the data structure directly to the handler I must. Further, if I am using Mongo - the persist functionality I want may always be something like "UpsertId" - but this may be different for an SQL variant. By giving my handler a MongoDB, I force my handler to be coupled to my Mongo-based persistence and my Mongo-compatibly implemented data ontology. Rather, if I define a DB interface, that allows me to find and store records, and I define User and Task interfaces, that allow me to perform operations on tasks, I can think about my ontology in more general terms, and I suddenly don't care about the implementation of my database. I could drop in a SQL variant tomorrow and so long as it fulfilled my interface it would work.

Thinking about things in terms of the interfaces they do or should expose simplifies system design. While building large computer systems the problem of dependencies and services and which packages supply what implementatin and which services supply which functionality can become an atrocious medley of coupled, inextricable software. Dependency inversion - stating the interfaces which you need, allows you to decouple software. Additionally it simplifies the actual implementations. Take our Mongo vs SQL example, so long as the database can be queried and can persist records it works with elos' stack. It doesn't matter how. For all I know - my database sends text messages to a monkey who stores the data as bunches of banana binary. **It does not matter**. There are fifty different ways to implement a data store. There are serveral good ways today. And when there is a better way tomorrow, elos will drop it in - and the system will still work.
